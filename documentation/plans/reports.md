# Plexus Reports Feature Plan

**Status Legend:**
*   â¬œ Not Started / To Do
*   ðŸŸ¡ In Progress
*   âœ… Completed

***Note on Testing:*** *Test files in this project are typically located directly adjacent to the source code file they are testing (e.g., `service.py` would have a corresponding `service_test.py` in the same directory).*

## Introduction

This document outlines the plan for implementing a flexible and extensible reporting system within the Plexus platform. The goal is to provide a standardized way to define, generate, store, and view various types of reports and analyses without requiring bespoke dashboard pages or API schema changes for each new report type. This system will support reports like feedback analysis, topic modeling, score performance summaries, and more.

## Core Concepts

The reporting system will be built around **four** core concepts:

*   **`ReportConfiguration`**: Defines the structure, content sources, and parameters for a specific type of report using Markdown and Jinja2 templating. It acts as a template for generating reports and specifies which `ReportBlock` Python classes to execute.
*   **`Report`**: Represents a specific instance of a report generated based on a `ReportConfiguration`. It stores the final rendered output (e.g., Markdown) in its `output` field and links to the individual `ReportBlock` results.
*   **`ReportBlock` (Database Model)**: Stores the structured JSON output and optional logs generated by a specific Python `ReportBlock` execution within a `Report` run. Each block has a defined `position` and an optional `name`.
*   **`ReportBlock` (Python Class)**: Reusable Python components responsible for generating specific sections or data points within a report. These blocks encapsulate the logic for fetching data and performing analysis, returning JSON data to be stored in the `ReportBlock` database model.

## Data Models

### `ReportConfiguration`

*   **Storage:** Likely stored as YAML or JSON within a new database model (e.g., `ReportConfiguration`). This allows for versioning and easy editing.
*   **Structure:**
    *   `name`: Human-readable name for the configuration.
    *   `description`: Optional description.
    *   `accountId`: Link to the owning account.
    *   `configuration`: The core YAML/JSON definition. This would specify:
        *   Static content (headers, paragraphs, images).
        *   Report Blocks to include, along with their specific parameters (e.g., `scorecardId`, `timeRange`, `pythonClass`).
        *   Layout or ordering information for the blocks.
    *   Standard metadata (`createdAt`, `updatedAt`, etc.).

### `Report`

*   **Storage:** A new database model (`Report`) linked to a `ReportConfiguration`.
*   **Structure:**
    *   `reportConfigurationId`: Link to the configuration used.
    *   `accountId`: Link to the owning account.
    *   `name`: Can be auto-generated or user-defined.
    *   `status`: (e.g., `PENDING`, `RUNNING`, `COMPLETED`, `FAILED`).
    *   `createdAt`, `startedAt`, `completedAt`: Timestamps for the run.
    *   `parameters`: Parameters used for this specific run (might override or supplement configuration).
    *   `output`: The final rendered report output, stored as a string (e.g., Markdown). Generated by processing the `ReportConfiguration.configuration` template.
    *   `reportData`: (Potentially deprecated or for internal use) Previously intended for raw JSON output.
    *   `errorMessage`, `errorDetails`: For tracking failures.
    *   `reportBlocks`: A one-to-many relationship linking to the individual `ReportBlock` results generated for this report.
    *   `shareLinks`: Association for shareable URLs.
    *   Standard metadata (`updatedAt`).

### `ReportBlock`

*   **Storage:** A new database model (`ReportBlock`) linked to a `Report`.
*   **Structure:**
    *   `reportId`: Link to the parent `Report`.
    *   `name`: Optional user-defined name for the block (extracted from the block definition in the configuration).
    *   `position`: Required integer indicating the order/position of the block within the report configuration.
    *   `output`: The structured data generated by the corresponding Python `ReportBlock` class, stored as JSON.
    *   `log`: Optional string containing logs or messages from the block's execution.
    *   Standard metadata (`createdAt`, `updatedAt`).
*   **Indexes:**
    *   `byReportAndName`: GSI to query blocks by `reportId` and `name`.
    *   `byReportAndPosition`: GSI to query blocks by `reportId` and `position`.

## Backend Implementation

### Python `ReportBlock` Framework

*   Define a base Python class (e.g., `plexus.reports.blocks.BaseReportBlock`).
*   Subclasses will implement specific report generation logic (e.g., `FeedbackAnalysisBlock`, `TopicModelBlock`, `ScorePerformanceBlock`).
*   Blocks will implement a standard method (e.g., `generate(config, params)`) that returns a JSON-serializable dictionary (stored in `ReportBlock.output`) and optionally a log string (stored in `ReportBlock.log`).
*   Blocks should have access to Plexus data fetching utilities (e.g., to query `Score`, `Evaluation`, `Item` data via the API or direct DB access if necessary).

### Report Generation Service

*   A mechanism to trigger report generation based on a `ReportConfiguration`.
*   Options:
    *   **CLI Command:** `plexus report run --config <config_id_or_name> [params...]`
    *   **Celery Task:** Dispatch report generation jobs to worker nodes, similar to evaluations. This is suitable for long-running reports.
*   The service will:
    1.  Load the `ReportConfiguration` and the specific run `parameters`.
    2.  Parse the `ReportConfiguration.configuration` Markdown to extract the block definitions (` ```block ... ``` ` including name, class, config, position) for execution. The parser should also reconstruct the original Markdown string, keeping the block definitions untouched.
    3.  **Process Blocks First:** For each extracted block definition (in order): Instantiates and calls the `generate` method for the specified Python `ReportBlock` class. Creates `ReportBlock` records storing the resulting JSON `output`, `log`, `name`, and `position`.
    4.  **Store Original Markdown:** Store the reconstructed, original Markdown string (from step 2, which includes the ` ```block ... ``` ` definitions) directly into the `Report.output` field. **Note:** This field does *not* contain the executed block outputs; those are only in the `ReportBlock` records.
    5.  **(Removed) Collect Block Results:** This step is no longer needed for generating `Report.output`.
    6.  **(Removed) Render Main Template Last:** This step is removed as we are storing the original Markdown, not rendering a template with block results.

## Frontend Implementation (Dashboard)

### Management Interface

*   New dashboard section for "Reports".
*   View/List existing `ReportConfiguration`s and `Report`s.
*   Create/Edit `ReportConfiguration`s:
    *   Potentially a YAML/JSON editor.
    *   A more user-friendly UI builder could be a future enhancement.
*   Trigger new `Report` runs from a configuration.

### Report Viewing

*   Dedicated page or component to display a `Report`.
*   Fetch the `Report` record, including its `output` string and its associated `ReportBlock` records (sorted by `position`).
*   Render the `Report.output` string, likely using a Markdown renderer component.
*   Display the data from the associated `ReportBlock` records. This could involve:
    *   A separate section/tab listing each block (by `name` or `position`).
    *   Dynamically rendering the `output` JSON from each `ReportBlock` using appropriate React components (tables, charts, key metrics, text sections) based on the JSON structure or hints within it.
*   **Sharing:** Integrate with the existing `ShareLink` system to allow sharing report URLs.
*   **Printing:** Implement CSS media queries (`@media print`) to provide a clean, printable version of the report view, removing UI chrome.

## Implementation Plan & Checklist

*   âœ… **Define Models:** Define `ReportConfiguration`, `Report`, and `ReportBlock` models in `dashboard/amplify/data/resource.ts`.
    *   âœ… Add fields for `ReportConfiguration` (name, description, accountId, configuration (json), createdAt, updatedAt).
    *   âœ… Add fields for `Report` (reportConfigurationId, accountId, name, status, createdAt, startedAt, completedAt, parameters (json), `output` (string), reportBlocks (relation), errorMessage, errorDetails, updatedAt). (Mark `reportData` as deprecated/internal).
    *   âœ… Add fields for `ReportBlock` (reportId, name, position, output (json), log, createdAt, updatedAt).
*   âœ… **Define Relationships:** Add necessary relationships (`Account` -> `ReportConfiguration`, `ReportConfiguration` -> `Report`, `Account` -> `Report`, `Report` -> `ReportBlock`).
*   âœ… **Add Indexes:** Define required secondary indexes (`ReportConfiguration` by accountId/updatedAt, name; `Report` by accountId/updatedAt, reportConfigurationId/createdAt, status; `ReportBlock` by reportId/name, reportId/position).

### Phase 1: Backend Foundation (Post-Schema)

*   âœ… **Create Base Python Class:** Create the base `plexus.reports.blocks.BaseReportBlock` Python class (`plexus/reports/blocks/base.py`) with a placeholder `generate` method.
*   âœ… **Verify Phase 1:** Confirm models exist in the backend and that the auto-generated base GraphQL CRUD operations (e.g., `getReport`, `listReports`, `createReportConfiguration`) work as expected via AppSync console or tests.

### Phase 2: Report Generation (Service & Triggering)

*   âœ… **Use Existing Test Block:** Use the existing `ScoreInfo` block (in `plexus/reports/blocks/score_info.py`) for initial testing instead of creating a separate `HelloWorld` block. *(Renamed from ScoreInfoBlock)*
*   ðŸŸ¡ **Develop Generation Service Core:** Create Python service logic (`plexus.reports.service`) that:
    *   ðŸŸ¡ Takes a `ReportConfiguration` ID and optional parameters. *(Function signature and basic structure added)*
    *   ðŸŸ¡ Loads the `ReportConfiguration` data. *(Stub `_load_report_configuration` added and called)*
    *   âœ… Parses the `configuration` field (Markdown/Jinja2) to identify static content, the main template structure, and ` ```block ... ``` ` definitions (including name, class, config, position). *(Implementation using ReportBlockExtractor added, returns original Markdown)*
    *   âœ… **Process Blocks First:** For each block definition (in order): Instantiates and calls the `generate` method for the specified Python `ReportBlock` class. Creates `ReportBlock` records storing the JSON `output`, `log`, `name`, and `position`. *(_instantiate_and_run_block implemented for basic execution and serialization, DB TODO)*
    *   ðŸŸ¡ **(Removed) Collect Block Results:** Gather the outputs from the executed blocks (e.g., into a dictionary accessible by block name or position). *(`block_outputs` dictionary created and populated from stub - This is still needed internally but not for `Report.output`)*
    *   ðŸŸ¡ **(Removed) Render Main Template Last:** Renders the main template using Jinja2, passing the collected block results (and other metadata/parameters) in the rendering context. Stores the final rendered string in `Report.output`. *(Jinja2 logic added, DB TODO - This step is removed, `Report.output` now stores original Markdown)*
*   â¬œ **Implement CLI Trigger:** Create the `plexus report run --config <config_id>` CLI command that:
    *   â¬œ Parses arguments.
    *   â¬œ Calls the generation service logic.
    *   â¬œ Creates/Updates the `Report` record (status, `output`) and associated `ReportBlock` records via GraphQL mutations.
*   ðŸŸ¡ **Basic Status Updates:** Ensure the `Report` record `status`, `startedAt`, `completedAt`, `errorMessage`, `output`, and `ReportBlock` records are updated/created correctly. *(Placeholders/TODOs exist)*
*   â¬œ **Implement Celery Task:** Wrap the generation service logic in a Celery task.
*   â¬œ **Implement Celery Dispatch:** Create a mechanism (e.g., internal API call, GraphQL mutation triggered by frontend) to dispatch the Celery task for report generation.
*   ðŸŸ¡ **Add Error Handling:** Implement robust error handling in the generation service and Celery task to capture exceptions and update the `Report` record with `errorMessage` and `errorDetails`. *(Partial implementation in _instantiate_and_run_block, needs further work, e.g., for YAML/Jinja errors)*
*   ðŸŸ¡ **Verify Phase 2:** Confirm reports can be generated via CLI, data is stored, status updates correctly. Test Celery task dispatch and execution. *(Basic tests passing for parsing and block execution happy path)*

### Phase 3: Frontend Basics (Management & Display)

*   â¬œ **Create "Reports" Dashboard Section:** Add a new top-level section/route (e.g., `/reports`) in the Next.js dashboard.
*   â¬œ **List Configurations:** Implement a UI table/list to display existing `ReportConfiguration`s fetched via GraphQL.
*   â¬œ **List Reports:** Implement a UI table/list to display existing `Report`s fetched via GraphQL, showing key metadata (name, status, created date).
*   â¬œ **Basic Configuration Editor:** Create a simple form/modal to create/edit `ReportConfiguration`s (editing name, description, and the raw `configuration` JSON/YAML for now). Use GraphQL mutations.
*   â¬œ **Trigger Generation from UI:** Add a button on the `ReportConfiguration` list/view to trigger a new report run (using the Celery dispatch mechanism from Phase 2).
*   â¬œ **Basic Report View:** Create a dedicated route/page (e.g., `/reports/[reportId]`) to display a single `Report`.
*   â¬œ **Fetch Report Data:** Implement logic on the report view page to fetch the full `Report` record (including `output`) and its associated `ReportBlock` records (ordered by `position`).
*   â¬œ **Initial Dynamic Rendering:** Develop a Markdown renderer for `Report.output`. Implement basic display for `ReportBlock` data (e.g., showing block name/position and its raw `output` JSON).
*   â¬œ **Verify Phase 3:** Confirm basic UI for listing, creating configurations, triggering runs, and viewing simple reports (rendered Markdown + basic block data) works.

### Phase 4: Advanced Features & Polish

*   â¬œ **Implement Core Report Blocks:**
    *   â¬œ Implement `FeedbackAnalysisBlock`.
    *   â¬œ Implement `ScorePerformanceBlock`.
    *   â¬œ Implement `TopicModelBlock` (if applicable).
*   â¬œ **Develop Corresponding React Components:** Create specific React components to visualize the data from `ReportBlock.output` JSON (e.g., charts for performance, tables for feedback, topic lists).
*   â¬œ **Enhance Dynamic Rendering:** Improve the report viewing component to intelligently select and render the appropriate React component based on the structure/type information within the `ReportBlock.output` JSON.
*   â¬œ **Integrate Sharing:** Connect the `Report` model to the `ShareLink` system.
*   â¬œ **Improve Configuration Editor:** Consider a more user-friendly UI beyond raw YAML/JSON/Markdown editing (future enhancement).
*   â¬œ **Refine Print Styles:** Ensure the `@media print` styles produce a high-quality printed report, handling block rendering appropriately.
*   â¬œ **Verify Phase 4:** Test complex reports with various blocks, ensure proper visualization, sharing, and printing.

## Example Report Configuration

Here is an example of the content stored in the `ReportConfiguration.configuration` field:

```block name="Term Life - Temperature Check - Score Information"
class: ScoreInformation
scorecard: termlifev1
score: Temperature Check
```

The parameters for blocks work in the same way as parameters to the CLI tools: `scorecard` can be an ID, an external ID, a key, or a name. Same for `score`.

When the report is generated, each report block in the report will generate structured JSON output that will be stored in a separate `ReportBlock` entry, linked to the `Report`. The JSON output for each block goes into `ReportBlock.output`. The block's execution logs can be stored in `ReportBlock.log`.

*(Note: The example above shows `ScoreInformation`. We should ensure consistency with the actual class name, which we intend to be `ScoreInfo`.)*

