# Plexus Reports Feature Plan

**Status Legend:**
*   â¬œ Not Started / To Do
*   ðŸŸ¡ In Progress
*   âœ… Completed

## Introduction

This document outlines the plan for implementing a flexible and extensible reporting system within the Plexus platform. The goal is to provide a standardized way to define, generate, store, and view various types of reports and analyses without requiring bespoke dashboard pages or API schema changes for each new report type. This system will support reports like feedback analysis, topic modeling, score performance summaries, and more.

## Core Concepts

The reporting system will be built around **four** core concepts:

*   **`ReportConfiguration`**: Defines the structure, content sources, and parameters for a specific type of report using Markdown and Jinja2 templating. It acts as a template for generating reports and specifies which `ReportBlock` Python classes to execute.
*   **`Report`**: Represents a specific instance of a report generated based on a `ReportConfiguration`. It stores the final rendered output (e.g., Markdown) in its `output` field and links to the individual `ReportBlock` results.
*   **`ReportBlock` (Database Model)**: Stores the structured JSON output and optional logs generated by a specific Python `ReportBlock` execution within a `Report` run. Each block has a defined `position` and an optional `name`.
*   **`ReportBlock` (Python Class)**: Reusable Python components responsible for generating specific sections or data points within a report. These blocks encapsulate the logic for fetching data and performing analysis, returning JSON data to be stored in the `ReportBlock` database model.

## Data Models

### `ReportConfiguration`

*   **Storage:** Likely stored as YAML or JSON within a new database model (e.g., `ReportConfiguration`). This allows for versioning and easy editing.
*   **Structure:**
    *   `name`: Human-readable name for the configuration.
    *   `description`: Optional description.
    *   `accountId`: Link to the owning account.
    *   `configuration`: The core YAML/JSON definition. This would specify:
        *   Static content (headers, paragraphs, images).
        *   Report Blocks to include, along with their specific parameters (e.g., `scorecardId`, `timeRange`, `pythonClass`).
        *   Layout or ordering information for the blocks.
    *   Standard metadata (`createdAt`, `updatedAt`, etc.).

### `Report`

*   **Storage:** A new database model (`Report`) linked to a `ReportConfiguration`.
*   **Structure:**
    *   `reportConfigurationId`: Link to the configuration used.
    *   `accountId`: Link to the owning account.
    *   `name`: Can be auto-generated or user-defined.
    *   `status`: (e.g., `PENDING`, `RUNNING`, `COMPLETED`, `FAILED`).
    *   `createdAt`, `startedAt`, `completedAt`: Timestamps for the run.
    *   `parameters`: Parameters used for this specific run (might override or supplement configuration).
    *   `output`: The final rendered report output, stored as a string (e.g., Markdown). Generated by processing the `ReportConfiguration.configuration` template.
    *   `reportData`: (Potentially deprecated or for internal use) Previously intended for raw JSON output.
    *   `errorMessage`, `errorDetails`: For tracking failures.
    *   `reportBlocks`: A one-to-many relationship linking to the individual `ReportBlock` results generated for this report.
    *   `shareLinks`: Association for shareable URLs.
    *   Standard metadata (`updatedAt`).

### `ReportBlock`

*   **Storage:** A new database model (`ReportBlock`) linked to a `Report`.
*   **Structure:**
    *   `reportId`: Link to the parent `Report`.
    *   `name`: Optional user-defined name for the block (extracted from the block definition in the configuration).
    *   `position`: Required integer indicating the order/position of the block within the report configuration.
    *   `output`: The structured data generated by the corresponding Python `ReportBlock` class, stored as JSON.
    *   `log`: Optional string containing logs or messages from the block's execution.
    *   Standard metadata (`createdAt`, `updatedAt`).
*   **Indexes:**
    *   `byReportAndName`: GSI to query blocks by `reportId` and `name`.
    *   `byReportAndPosition`: GSI to query blocks by `reportId` and `position`.

## Backend Implementation

### Python `ReportBlock` Framework

*   Define a base Python class (e.g., `plexus.reports.blocks.BaseReportBlock`).
*   Subclasses will implement specific report generation logic (e.g., `FeedbackAnalysisBlock`, `TopicModelBlock`, `ScorePerformanceBlock`).
*   Blocks will implement a standard method (e.g., `generate(config, params)`) that returns a JSON-serializable dictionary (stored in `ReportBlock.output`) and optionally a log string (stored in `ReportBlock.log`).
*   Blocks should have access to Plexus data fetching utilities (e.g., to query `Score`, `Evaluation`, `Item` data via the API or direct DB access if necessary).

### Report Generation Service

*   A mechanism to trigger report generation based on a `ReportConfiguration`.
*   Options:
    *   **CLI Command:** `plexus report run --config <config_id_or_name> [params...]`
    *   **Celery Task:** Dispatch report generation jobs to worker nodes, similar to evaluations. This is suitable for long-running reports.
*   The service will:
    1.  Load the `ReportConfiguration` and the specific run `parameters`.
    2.  Parse the `ReportConfiguration.configuration` Markdown/Jinja2 template to identify static content and report block definitions (e.g., using ` ```block ... ``` ` syntax).
    3.  Render the main template content using Jinja2 (passing `parameters` and other relevant context) to produce the final report string. Store this in `Report.output`.
    4.  For each identified ` ```block ... ``` ` definition (in order of appearance):
        *   Extract the block `name` (if provided) and configuration parameters (e.g., `class`, `scorecard`, `score`).
        *   Determine the block's `position`.
        *   Instantiate the specified Python `ReportBlock` subclass.
        *   Execute its `generate` method with the provided parameters.
        *   Create a `ReportBlock` database record, storing the returned `output` (JSON), `log` (string), `name`, `position`, and linking it to the parent `Report`.
    5.  Create/Update the `Report` database record with the final `status` and the generated `output`. Handle any errors during block execution and update `Report.errorMessage`/`errorDetails` or `ReportBlock.log`.

## Frontend Implementation (Dashboard)

### Management Interface

*   New dashboard section for "Reports".
*   View/List existing `ReportConfiguration`s and `Report`s.
*   Create/Edit `ReportConfiguration`s:
    *   Potentially a YAML/JSON editor.
    *   A more user-friendly UI builder could be a future enhancement.
*   Trigger new `Report` runs from a configuration.

### Report Viewing

*   Dedicated page or component to display a `Report`.
*   Fetch the `Report` record, including its `output` string and its associated `ReportBlock` records (sorted by `position`).
*   Render the `Report.output` string, likely using a Markdown renderer component.
*   Display the data from the associated `ReportBlock` records. This could involve:
    *   A separate section/tab listing each block (by `name` or `position`).
    *   Dynamically rendering the `output` JSON from each `ReportBlock` using appropriate React components (tables, charts, key metrics, text sections) based on the JSON structure or hints within it.
*   **Sharing:** Integrate with the existing `ShareLink` system to allow sharing report URLs.
*   **Printing:** Implement CSS media queries (`@media print`) to provide a clean, printable version of the report view, removing UI chrome.

## Implementation Plan & Checklist

*   âœ… **Define Models:** Define `ReportConfiguration`, `Report`, and `ReportBlock` models in `dashboard/amplify/data/resource.ts`.
    *   âœ… Add fields for `ReportConfiguration` (name, description, accountId, configuration (json), createdAt, updatedAt).
    *   âœ… Add fields for `Report` (reportConfigurationId, accountId, name, status, createdAt, startedAt, completedAt, parameters (json), `output` (string), reportBlocks (relation), errorMessage, errorDetails, updatedAt). (Mark `reportData` as deprecated/internal).
    *   âœ… Add fields for `ReportBlock` (reportId, name, position, output (json), log, createdAt, updatedAt).
*   âœ… **Define Relationships:** Add necessary relationships (`Account` -> `ReportConfiguration`, `ReportConfiguration` -> `Report`, `Account` -> `Report`, `Report` -> `ReportBlock`).
*   âœ… **Add Indexes:** Define required secondary indexes (`ReportConfiguration` by accountId/updatedAt, name; `Report` by accountId/updatedAt, reportConfigurationId/createdAt, status; `ReportBlock` by reportId/name, reportId/position).

### Phase 1: Backend Foundation (Post-Schema)

*   â¬œ **Deploy Schema:** Run `amplify sandbox` or deploy changes to update the backend schema and generate GraphQL assets.
*   â¬œ **Create Base Python Class:** Create the base `plexus.reports.blocks.BaseReportBlock` Python class with a placeholder `generate` method.
*   â¬œ **Implement Base GraphQL:** Create initial GraphQL queries/mutations for basic CRUD operations on `ReportConfiguration` and `Report` (listing, getting, creating basic records without generation logic).
*   â¬œ **Verify Phase 1:** Confirm models are created in DynamoDB, basic GraphQL queries work via AppSync console or tests.

### Phase 2: Report Generation (Service & Triggering)

*   â¬œ **Implement Test Block:** Implement a simple `HelloWorldReportBlock` in Python that returns static JSON data for testing.
*   â¬œ **Develop Generation Service Core:** Create Python service logic (`plexus.reports.service`) that:
    *   â¬œ Takes a `ReportConfiguration` ID and optional parameters.
    *   â¬œ Loads the `ReportConfiguration` data.
    *   â¬œ Parses the `configuration` field (Markdown/Jinja2) to identify static content and ` ```block ... ``` ` definitions.
    *   â¬œ Renders the main template using Jinja2 and stores the result in `Report.output`.
    *   â¬œ For each block definition: Instantiates and calls the `generate` method for the specified Python `ReportBlock` class.
    *   â¬œ Creates `ReportBlock` records storing the JSON `output`, `log`, `name`, and `position`.
*   â¬œ **Implement CLI Trigger:** Create the `plexus report run --config <config_id>` CLI command that:
    *   â¬œ Parses arguments.
    *   â¬œ Calls the generation service logic.
    *   â¬œ Creates/Updates the `Report` record (status, `output`) and associated `ReportBlock` records via GraphQL mutations.
*   â¬œ **Basic Status Updates:** Ensure the `Report` record `status`, `startedAt`, `completedAt`, `errorMessage`, `output`, and `ReportBlock` records are updated/created correctly.
*   â¬œ **Implement Celery Task:** Wrap the generation service logic in a Celery task.
*   â¬œ **Implement Celery Dispatch:** Create a mechanism (e.g., internal API call, GraphQL mutation triggered by frontend) to dispatch the Celery task for report generation.
*   â¬œ **Add Error Handling:** Implement robust error handling in the generation service and Celery task to capture exceptions and update the `Report` record with `errorMessage` and `errorDetails`.
*   â¬œ **Verify Phase 2:** Confirm reports can be generated via CLI, data is stored, status updates correctly. Test Celery task dispatch and execution.

### Phase 3: Frontend Basics (Management & Display)

*   â¬œ **Create "Reports" Dashboard Section:** Add a new top-level section/route (e.g., `/reports`) in the Next.js dashboard.
*   â¬œ **List Configurations:** Implement a UI table/list to display existing `ReportConfiguration`s fetched via GraphQL.
*   â¬œ **List Reports:** Implement a UI table/list to display existing `Report`s fetched via GraphQL, showing key metadata (name, status, created date).
*   â¬œ **Basic Configuration Editor:** Create a simple form/modal to create/edit `ReportConfiguration`s (editing name, description, and the raw `configuration` JSON/YAML for now). Use GraphQL mutations.
*   â¬œ **Trigger Generation from UI:** Add a button on the `ReportConfiguration` list/view to trigger a new report run (using the Celery dispatch mechanism from Phase 2).
*   â¬œ **Basic Report View:** Create a dedicated route/page (e.g., `/reports/[reportId]`) to display a single `Report`.
*   â¬œ **Fetch Report Data:** Implement logic on the report view page to fetch the full `Report` record (including `output`) and its associated `ReportBlock` records (ordered by `position`).
*   â¬œ **Initial Dynamic Rendering:** Develop a Markdown renderer for `Report.output`. Implement basic display for `ReportBlock` data (e.g., showing block name/position and its raw `output` JSON).
*   â¬œ **Verify Phase 3:** Confirm basic UI for listing, creating configurations, triggering runs, and viewing simple reports (rendered Markdown + basic block data) works.

### Phase 4: Advanced Features & Polish

*   â¬œ **Implement Core Report Blocks:**
    *   â¬œ Implement `FeedbackAnalysisBlock`.
    *   â¬œ Implement `ScorePerformanceBlock`.
    *   â¬œ Implement `TopicModelBlock` (if applicable).
*   â¬œ **Develop Corresponding React Components:** Create specific React components to visualize the data from `ReportBlock.output` JSON (e.g., charts for performance, tables for feedback, topic lists).
*   â¬œ **Enhance Dynamic Rendering:** Improve the report viewing component to intelligently select and render the appropriate React component based on the structure/type information within the `ReportBlock.output` JSON.
*   â¬œ **Integrate Sharing:** Connect the `Report` model to the `ShareLink` system.
*   â¬œ **Improve Configuration Editor:** Consider a more user-friendly UI beyond raw YAML/JSON/Markdown editing (future enhancement).
*   â¬œ **Refine Print Styles:** Ensure the `@media print` styles produce a high-quality printed report, handling block rendering appropriately.
*   â¬œ **Verify Phase 4:** Test complex reports with various blocks, ensure proper visualization, sharing, and printing.

## Example Report Configuration

Here is an example of the content stored in the `ReportConfiguration.configuration` field:

````markdown
# Example Report

This is a demo Plexus report. A report configuration can contain content like this, in the Markdown code in the `configuration` item.

## Metadata

Reports can use Jinja2 template language to interpolate things, like metadata:

Report ID: {{ metadata.report_id }}
Run Parameters: {{ parameters }} {# Example: Accessing run-time parameters #}

## Output

When this report configuration is processed, it will generate a `Report` record in the API. The Jinja2-processed report output goes into the `Report.output` item in that record.

## Example Report Block

Reports can run analysis tasks and other processing as report blocks, which are Python classes that generate structured data (JSON) logged in `ReportBlock` records in the API.

Report blocks are added as normal Markdown code blocks using the `block` language identifier. Each includes YAML configuration code within the block. Here's an example:

```block name="Term Life - Temperature Check - Score Information"
class: ScoreInformation
scorecard: termlifev1
score: Temperature Check
```

The parameters for blocks work in the same way as parameters to the CLI tools: `scorecard` can be an ID, an external ID, a key, or a name. Same for `score`.

When the report is generated, each report block in the report will generate structured JSON output that will be stored in a separate `ReportBlock` entry, linked to the `Report`. The JSON output for each block goes into `ReportBlock.output`. The block's execution logs can be stored in `ReportBlock.log`.
````

*(Note: The example uses four backticks for the outer Markdown block to correctly embed the inner triple-backtick code block within the documentation.)*

