<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examples & Patterns - Plexus Procedure DSL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header .breadcrumb {
            opacity: 0.9;
        }

        .header .breadcrumb a {
            color: white;
            text-decoration: none;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }

        .content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        h2 {
            color: #667eea;
            margin: 2rem 0 1rem 0;
            font-size: 1.8rem;
        }

        h3 {
            color: #764ba2;
            margin: 1.5rem 0 0.5rem 0;
            font-size: 1.3rem;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .example-card {
            background: #f9f9f9;
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .example-card h3 {
            margin-top: 0;
            color: #667eea;
        }

        .tag {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .tag.beginner {
            background: #8bc34a;
        }

        .tag.intermediate {
            background: #ff9800;
        }

        .tag.advanced {
            background: #f44336;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .tip-box {
            background: #f1f8e9;
            border-left: 4px solid #8bc34a;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        code {
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }

        ul {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        li {
            margin: 0.5rem 0;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #ddd;
        }

        .nav-links a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .nav-links a:hover {
            text-decoration: underline;
        }

        .toc {
            background: #f9f9f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .toc h3 {
            margin-top: 0;
        }

        .toc ul {
            list-style: none;
            padding-left: 0;
        }

        .toc li {
            margin: 0.5rem 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
        }

        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="breadcrumb">
            <a href="index.html">Documentation</a> / Examples & Patterns
        </div>
        <h1>Examples & Patterns</h1>
    </div>

    <div class="container">
        <div class="content">
            <p>
                This guide provides real-world examples of Plexus Procedures, from simple tasks to
                complex multi-stage workflows with human-in-the-loop interaction. Each example includes
                complete code and explanations of key concepts.
            </p>

            <div class="toc">
                <h3>Examples</h3>
                <ul>
                    <li><a href="#simple-research">Simple Research Task</a></li>
                    <li><a href="#data-processing">Data Processing with Progress</a></li>
                    <li><a href="#content-pipeline">Content Pipeline with HITL</a></li>
                    <li><a href="#parallel-research">Parallel Research</a></li>
                    <li><a href="#recursive-decomposition">Recursive Task Decomposition</a></li>
                    <li><a href="#monitoring">Batch Processing with Monitoring</a></li>
                    <li><a href="#deployment">Deployment Pipeline</a></li>
                    <li><a href="#multi-agent">Multi-Agent Workflow</a></li>
                </ul>
            </div>

            <div class="example-card" id="simple-research">
                <h3>Simple Research Task</h3>
                <span class="tag beginner">Beginner</span>
                <span class="tag">Single Agent</span>
                <p>A straightforward procedure that researches a topic and returns findings.</p>

                <div class="code-block">name: simple_researcher
version: 1.0.0
description: Research a topic and provide a summary

params:
  topic:
    type: string
    required: true
    description: "The topic to research"

outputs:
  summary:
    type: string
    required: true
  confidence:
    type: string
    enum: [high, medium, low]
    required: true

agents:
  researcher:
    system_prompt: |
      Research the topic: {params.topic}
      Use the search tool to find information.
      Provide a concise summary of key findings.
      Call 'done' when complete.

    tools:
      - search
      - done

    max_turns: 10

return_prompt: |
  Provide your research summary and confidence level (high/medium/low).
  Format: {"summary": "...", "confidence": "..."}

workflow: |
  -- Simple loop until done
  repeat
    Researcher.turn()
  until Tool.called("done") or Iterations.exceeded(10)

  return {
    summary = State.get("summary") or "No summary available",
    confidence = State.get("confidence") or "low"
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Basic parameter and output schemas</li>
                        <li>Simple repeat-until loop</li>
                        <li>Tool completion checking</li>
                        <li>Iteration limits for safety</li>
                        <li>Return prompt for structured output</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="data-processing">
                <h3>Data Processing with Progress</h3>
                <span class="tag beginner">Beginner</span>
                <span class="tag">State Management</span>
                <span class="tag">Progress Tracking</span>
                <p>Process items with state tracking and progress updates.</p>

                <div class="code-block">name: data_processor
version: 1.0.0
description: Process a list of items with progress tracking

params:
  items:
    type: array
    required: true
  batch_size:
    type: number
    default: 10

outputs:
  processed:
    type: number
    required: true
  failed:
    type: number
    required: true
  results:
    type: array
    required: true

stages:
  - initializing
  - processing
  - complete

agents:
  processor:
    system_prompt: |
      Process items one at a time.
      Progress: {state.processed}/{state.total}
      Failed: {state.failed}

    tools:
      - process_item
      - validate
      - done

workflow: |
  Stage.set("initializing")

  -- Initialize state
  State.set("processed", 0)
  State.set("failed", 0)
  State.set("total", #params.items)
  State.set("results", {})

  Stage.set("processing")
  Human.notify({
    message = "Starting processing",
    level = "info",
    context = {total = #params.items}
  })

  -- Process each item
  for i, item in ipairs(params.items) do
    local ok, result = pcall(function()
      Processor.turn({inject = "Process: " .. Json.encode(item)})
      return State.get("last_result")
    end)

    if ok and result then
      State.increment("processed")
      State.append("results", result)
    else
      State.increment("failed")
      Log.error("Failed to process item " .. i, {error = result})
    end

    -- Progress notification every batch_size items
    if i % params.batch_size == 0 then
      Human.notify({
        message = "Progress: " .. i .. "/" .. #params.items,
        level = "info",
        context = {
          processed = State.get("processed"),
          failed = State.get("failed")
        }
      })
    end
  end

  Stage.set("complete")
  Human.notify({
    message = "Processing complete",
    level = "info",
    context = {
      processed = State.get("processed"),
      failed = State.get("failed")
    }
  })

  return {
    processed = State.get("processed"),
    failed = State.get("failed"),
    results = State.get("results")
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>State initialization and management</li>
                        <li>Progress tracking with counters</li>
                        <li>Error handling with pcall</li>
                        <li>Periodic notifications</li>
                        <li>Stage transitions</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="content-pipeline">
                <h3>Content Pipeline with HITL</h3>
                <span class="tag intermediate">Intermediate</span>
                <span class="tag">HITL</span>
                <span class="tag">Multi-Stage</span>
                <p>Generate content, review with human, and publish with approval.</p>

                <div class="code-block">name: content_pipeline
version: 1.0.0
description: Generate, review, and publish content with human oversight

params:
  topic:
    type: string
    required: true
  target:
    type: string
    enum: [blog, docs, social]
    required: true
  style:
    type: string
    enum: [formal, casual, technical]
    default: casual

outputs:
  published:
    type: boolean
    required: true
  url:
    type: string
    required: false
  final_content:
    type: string
    required: false

stages:
  - researching
  - drafting
  - review
  - publishing
  - complete

hitl:
  review_content:
    type: review
    message: "Review the generated content before publishing"
    timeout: 86400  # 24 hours
    options: [approve, edit, reject]

  confirm_publish:
    type: approval
    message: "Publish to {params.target}?"
    timeout: 3600   # 1 hour
    default: false

agents:
  writer:
    system_prompt: |
      Write content about: {params.topic}
      Target: {params.target}
      Style: {params.style}

      Steps:
      1. Research the topic
      2. Create an outline
      3. Write the full content
      4. Mark done when complete

    tools:
      - research
      - outline
      - write
      - done

    max_turns: 30

return_prompt: |
  Provide the final content you've written.

workflow: |
  -- Research phase
  Stage.set("researching")
  Human.notify({
    message = "Starting content generation",
    level = "info",
    context = {
      topic = params.topic,
      target = params.target,
      style = params.style
    }
  })

  -- Generate draft
  Stage.set("drafting")
  repeat
    Writer.turn()
  until Tool.called("done") or Iterations.exceeded(30)

  local draft = State.get("draft")
  if not draft then
    System.alert({
      message = "Failed to generate draft",
      level = "error",
      source = "content_pipeline",
      context = {topic = params.topic}
    })
    return {
      published = false,
      error = "No draft generated"
    }
  end

  -- Human review
  Stage.set("review")
  local review = Human.review("review_content", {
    artifact = draft,
    artifact_type = "document"
  })

  if review.decision == "reject" then
    Human.notify({
      message = "Content rejected",
      level = "warning",
      context = {
        feedback = review.feedback
      }
    })
    return {
      published = false,
      reason = "rejected",
      feedback = review.feedback
    }
  end

  -- Use edited or original version
  local final_content = review.edited_artifact or draft

  -- Final approval
  Stage.set("publishing")
  local approved = Human.approve("confirm_publish", {
    context = {
      content_length = #final_content,
      word_count = #final_content / 5,  -- Rough estimate
      estimated_read_time = math.ceil(#final_content / 1000) .. " min"
    }
  })

  if not approved then
    return {
      published = false,
      reason = "not_approved",
      final_content = final_content
    }
  end

  -- Publish
  local url = publish_content(final_content, params.target)

  -- Success notification
  Human.notify({
    message = "Content published successfully",
    level = "info",
    context = {
      url = url,
      target = params.target,
      length = #final_content
    }
  })

  Stage.set("complete")
  return {
    published = true,
    url = url,
    final_content = final_content
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Declarative HITL points</li>
                        <li>Review with editing capability</li>
                        <li>Approval with context</li>
                        <li>Notifications at key points</li>
                        <li>System alerts for errors</li>
                        <li>Multiple stage transitions</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="parallel-research">
                <h3>Parallel Research</h3>
                <span class="tag intermediate">Intermediate</span>
                <span class="tag">Async</span>
                <span class="tag">Parallel</span>
                <p>Research multiple topics in parallel and aggregate results.</p>

                <div class="code-block">name: parallel_researcher
version: 1.0.0
description: Research multiple topics in parallel

params:
  topics:
    type: array
    required: true
  depth:
    type: string
    enum: [shallow, deep]
    default: shallow

outputs:
  results:
    type: array
    required: true
  summary:
    type: string
    required: true

# Inline procedure definition
procedures:
  researcher:
    params:
      topic:
        type: string
        required: true
      depth:
        type: string
        required: true

    outputs:
      findings:
        type: string
        required: true
      confidence:
        type: string
        enum: [high, medium, low]
        required: true

    agents:
      worker:
        system_prompt: |
          Research: {params.topic}
          Depth: {params.depth}

        tools:
          - search
          - done

    workflow: |
      repeat
        Worker.turn()
      until Tool.called("done") or Iterations.exceeded(10)

      return {
        findings = State.get("findings") or "",
        confidence = State.get("confidence") or "low"
      }

stages:
  - spawning
  - researching
  - aggregating
  - complete

agents:
  aggregator:
    system_prompt: |
      Synthesize research findings from multiple topics.
      Create a coherent summary that connects the insights.

    tools:
      - done

workflow: |
  Stage.set("spawning")
  Human.notify({
    message = "Starting parallel research",
    level = "info",
    context = {topic_count = #params.topics}
  })

  -- Spawn researchers in parallel
  local handles = {}
  for _, topic in ipairs(params.topics) do
    local handle = Procedure.spawn("researcher", {
      topic = topic,
      depth = params.depth
    })
    table.insert(handles, handle)
    Log.info("Spawned researcher for: " .. topic)
  end

  -- Monitor progress
  Stage.set("researching")
  while not Procedure.all_complete(handles) do
    Sleep(5)

    local completed = 0
    for _, handle in ipairs(handles) do
      if Procedure.is_complete(handle) then
        completed = completed + 1
      end
    end

    Human.notify({
      message = "Research progress: " .. completed .. "/" .. #handles,
      level = "info"
    })
  end

  -- Collect results
  local results = {}
  for i, handle in ipairs(handles) do
    local result = Procedure.result(handle)
    table.insert(results, {
      topic = params.topics[i],
      findings = result.findings,
      confidence = result.confidence
    })
  end

  -- Aggregate
  Stage.set("aggregating")
  State.set("research_results", results)
  Aggregator.turn({inject = "Synthesize these findings: " .. Json.encode(results)})

  Stage.set("complete")
  return {
    results = results,
    summary = State.get("summary") or "No summary generated"
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Inline procedure definitions</li>
                        <li>Async procedure spawning</li>
                        <li>Progress monitoring</li>
                        <li>Waiting for all completions</li>
                        <li>Result aggregation</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="recursive-decomposition">
                <h3>Recursive Task Decomposition</h3>
                <span class="tag advanced">Advanced</span>
                <span class="tag">Recursion</span>
                <span class="tag">Multi-Agent</span>
                <p>Recursively decompose complex tasks into subtasks.</p>

                <div class="code-block">name: task_decomposer
version: 1.0.0
description: Recursively decompose and execute complex tasks

params:
  task:
    type: string
    required: true
  depth:
    type: number
    default: 3
  context:
    type: object
    default: {}

outputs:
  result:
    type: string
    required: true
  subtasks_executed:
    type: number
    required: true

max_depth: 10

agents:
  analyzer:
    system_prompt: |
      Analyze this task: {params.task}
      Remaining depth: {params.depth}

      Decide if this task is:
      - Simple enough to execute directly (use 'execute' tool)
      - Complex and needs decomposition (use 'decompose' tool)

    tools:
      - execute
      - decompose
      - done

  executor:
    system_prompt: |
      Execute this simple task: {params.task}

    tools:
      - perform
      - done

workflow: |
  State.set("subtasks_count", 0)

  -- Base case: depth exhausted, must execute
  if params.depth <= 0 then
    Log.info("Max depth reached, executing directly")
    repeat
      Executor.turn()
    until Tool.called("done") or Iterations.exceeded(5)

    return {
      result = State.get("result") or "executed",
      subtasks_executed = 1
    }
  end

  -- Analyze task
  Analyzer.turn()

  if Tool.called("decompose") then
    -- Complex task: decompose into subtasks
    local subtasks = State.get("subtasks") or {}

    if #subtasks == 0 then
      Log.warn("No subtasks generated, executing directly")
      Executor.turn()
      return {
        result = State.get("result") or "executed",
        subtasks_executed = 1
      }
    end

    Log.info("Decomposed into " .. #subtasks .. " subtasks")

    -- Recurse for each subtask
    local results = {}
    local total_subtasks = 0

    for i, subtask in ipairs(subtasks) do
      Log.info("Executing subtask " .. i .. ": " .. subtask)

      local sub_result = Procedure.run("task_decomposer", {
        task = subtask,
        depth = params.depth - 1,
        context = {parent_task = params.task}
      })

      table.insert(results, sub_result.result)
      total_subtasks = total_subtasks + sub_result.subtasks_executed
    end

    -- Combine results
    return {
      result = table.concat(results, "; "),
      subtasks_executed = total_subtasks
    }

  else
    -- Simple task: execute directly
    Log.info("Executing simple task directly")
    repeat
      Executor.turn()
    until Tool.called("done") or Iterations.exceeded(5)

    return {
      result = State.get("result") or "executed",
      subtasks_executed = 1
    }
  end</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Recursive procedure invocation</li>
                        <li>Depth limiting with max_depth</li>
                        <li>Multiple agents (analyzer, executor)</li>
                        <li>Base case handling</li>
                        <li>Result aggregation from subtasks</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="monitoring">
                <h3>Batch Processing with Monitoring</h3>
                <span class="tag intermediate">Intermediate</span>
                <span class="tag">Monitoring</span>
                <span class="tag">Error Handling</span>
                <p>Process batches with failure monitoring and alerts.</p>

                <div class="code-block">name: batch_processor
version: 1.0.0
description: Process batches with failure rate monitoring

params:
  items:
    type: array
    required: true
  failure_threshold:
    type: number
    default: 0.1  # 10%
  alert_on_failure:
    type: boolean
    default: true

outputs:
  processed:
    type: number
    required: true
  failed:
    type: number
    required: true
  aborted:
    type: boolean
    required: true

stages:
  - processing
  - complete

agents:
  processor:
    system_prompt: |
      Process items one at a time.
      Be thorough and careful.

    tools:
      - process
      - validate
      - done

workflow: |
  Stage.set("processing")

  local processed = 0
  local failed = 0
  local total = #params.items

  Human.notify({
    message = "Starting batch processing",
    level = "info",
    context = {total = total}
  })

  for i, item in ipairs(params.items) do
    -- Process item
    local ok, result = pcall(function()
      Processor.turn({inject = "Process: " .. Json.encode(item)})
      return Tool.called("done")
    end)

    if ok and result then
      processed = processed + 1
    else
      failed = failed + 1
      Log.error("Failed item " .. i, {error = result})
    end

    -- Check failure rate
    local failure_rate = failed / i

    if failure_rate > params.failure_threshold and i > 10 then
      -- Alert on high failure rate
      if params.alert_on_failure then
        System.alert({
          message = "Failure rate exceeded threshold",
          level = "warning",
          source = "batch_processor",
          context = {
            failure_rate = failure_rate,
            threshold = params.failure_threshold,
            processed = i,
            failed = failed,
            total = total
          }
        })
      end

      -- Ask human whether to continue
      local continue = Human.approve({
        message = "Failure rate is " .. math.floor(failure_rate * 100) .. "%. Continue processing?",
        context = {
          failure_rate = failure_rate,
          processed = i,
          failed = failed,
          remaining = total - i
        },
        default = false,
        timeout = 300  -- 5 minutes
      })

      if not continue then
        Log.warn("Batch processing aborted by operator")
        Stage.set("complete")
        return {
          processed = processed,
          failed = failed,
          aborted = true
        }
      end
    end

    -- Progress notification every 100 items
    if i % 100 == 0 then
      Human.notify({
        message = "Progress: " .. i .. "/" .. total,
        level = "info",
        context = {
          processed = processed,
          failed = failed,
          failure_rate = failure_rate
        }
      })
    end
  end

  Stage.set("complete")

  local level = failed > 0 and "warning" or "info"
  Human.notify({
    message = "Batch processing complete",
    level = level,
    context = {
      processed = processed,
      failed = failed,
      total = total
    }
  })

  return {
    processed = processed,
    failed = failed,
    aborted = false
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Failure rate monitoring</li>
                        <li>System alerts for thresholds</li>
                        <li>Human approval on errors</li>
                        <li>Graceful abort handling</li>
                        <li>Progress notifications</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="deployment">
                <h3>Deployment Pipeline</h3>
                <span class="tag advanced">Advanced</span>
                <span class="tag">HITL</span>
                <span class="tag">Multi-Stage</span>
                <p>Complete deployment pipeline with verification and approvals.</p>

                <div class="code-block">name: deployment_pipeline
version: 1.0.0
description: Deploy application with verification and rollback

params:
  version:
    type: string
    required: true
  environment:
    type: string
    enum: [staging, production]
    required: true
  skip_tests:
    type: boolean
    default: false

outputs:
  deployed:
    type: boolean
    required: true
  url:
    type: string
    required: false
  rollback_available:
    type: boolean
    required: true

stages:
  - preparing
  - testing
  - approval
  - deploying
  - verifying
  - complete

hitl:
  approve_deployment:
    type: approval
    message: "Deploy {params.version} to {params.environment}?"
    timeout: 1800
    default: false

  approve_rollback:
    type: approval
    message: "Deployment verification failed. Rollback?"
    timeout: 600
    default: true

workflow: |
  -- Prepare
  Stage.set("preparing")
  Human.notify({
    message = "Preparing deployment",
    level = "info",
    context = {
      version = params.version,
      environment = params.environment
    }
  })

  -- Build and prepare artifacts
  local build_ok = build_artifacts(params.version)
  if not build_ok then
    System.alert({
      message = "Build failed",
      level = "error",
      source = "deployment_pipeline"
    })
    return {deployed = false, rollback_available = false}
  end

  -- Test
  if not params.skip_tests then
    Stage.set("testing")
    Human.notify({message = "Running tests", level = "info"})

    local tests_ok = run_tests()
    if not tests_ok then
      System.alert({
        message = "Tests failed",
        level = "error",
        source = "deployment_pipeline"
      })
      return {deployed = false, rollback_available = false}
    end
  end

  -- Get approval
  Stage.set("approval")
  local approved = Human.approve("approve_deployment", {
    context = {
      version = params.version,
      environment = params.environment,
      tests_passed = not params.skip_tests,
      risk_level = params.environment == "production" and "high" or "medium"
    }
  })

  if not approved then
    Log.info("Deployment cancelled")
    return {deployed = false, rollback_available = false}
  end

  -- Deploy
  Stage.set("deploying")
  Human.notify({
    message = "Deploying to " .. params.environment,
    level = "info"
  })

  local deploy_ok, url = deploy(params.version, params.environment)

  if not deploy_ok then
    System.alert({
      message = "Deployment failed",
      level = "critical",
      source = "deployment_pipeline"
    })
    return {deployed = false, rollback_available = true}
  end

  -- Verify
  Stage.set("verifying")
  Human.notify({
    message = "Verifying deployment",
    level = "info"
  })

  Sleep(30)  -- Let deployment stabilize

  local verify_ok = verify_deployment(url)

  if not verify_ok then
    System.alert({
      message = "Deployment verification failed",
      level = "critical",
      source = "deployment_pipeline",
      context = {url = url}
    })

    -- Ask about rollback
    local rollback = Human.approve("approve_rollback")

    if rollback then
      Human.notify({
        message = "Rolling back deployment",
        level = "warning"
      })
      rollback_deployment(params.environment)
      return {deployed = false, rollback_available = true}
    end
  end

  -- Success
  Stage.set("complete")
  Human.notify({
    message = "Deployment successful",
    level = "info",
    context = {
      version = params.version,
      environment = params.environment,
      url = url
    }
  })

  return {
    deployed = true,
    url = url,
    rollback_available = true
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Multi-stage pipeline</li>
                        <li>Pre-deployment approval</li>
                        <li>Post-deployment verification</li>
                        <li>Rollback on failure</li>
                        <li>Critical alerts</li>
                        <li>Stage-based progress tracking</li>
                    </ul>
                </div>
            </div>

            <div class="example-card" id="multi-agent">
                <h3>Multi-Agent Workflow</h3>
                <span class="tag advanced">Advanced</span>
                <span class="tag">Multi-Agent</span>
                <span class="tag">Collaboration</span>
                <p>Multiple specialized agents collaborating on a task.</p>

                <div class="code-block">name: multi_agent_analyzer
version: 1.0.0
description: Multiple agents analyze data from different perspectives

params:
  data:
    type: string
    required: true

outputs:
  analysis:
    type: object
    required: true

stages:
  - planning
  - technical_analysis
  - business_analysis
  - synthesis
  - complete

agents:
  planner:
    system_prompt: |
      You are a planning agent.
      Create an analysis plan for: {params.data}

    tools:
      - create_plan
      - done

  technical_analyst:
    system_prompt: |
      You are a technical analyst.
      Analyze technical aspects of: {params.data}
      Plan: {state.plan}

    tools:
      - analyze_technical
      - done

  business_analyst:
    system_prompt: |
      You are a business analyst.
      Analyze business implications of: {params.data}
      Plan: {state.plan}

    tools:
      - analyze_business
      - done

  synthesizer:
    system_prompt: |
      You are a synthesis agent.
      Combine these analyses into coherent insights:
      - Technical: {state.technical_analysis}
      - Business: {state.business_analysis}

    tools:
      - synthesize
      - done

workflow: |
  -- Planning phase
  Stage.set("planning")
  Human.notify({
    message = "Creating analysis plan",
    level = "info"
  })

  Planner.turn()
  local plan = State.get("plan")

  if not plan then
    return {analysis = {error = "Failed to create plan"}}
  end

  -- Technical analysis
  Stage.set("technical_analysis")
  Human.notify({
    message = "Running technical analysis",
    level = "info"
  })

  repeat
    Technical_analyst.turn()
  until Tool.called("done", "technical_analyst") or Iterations.exceeded(10)

  local technical = State.get("technical_analysis")

  -- Business analysis (can run in parallel with technical)
  Stage.set("business_analysis")
  Human.notify({
    message = "Running business analysis",
    level = "info"
  })

  repeat
    Business_analyst.turn()
  until Tool.called("done", "business_analyst") or Iterations.exceeded(10)

  local business = State.get("business_analysis")

  -- Synthesis
  Stage.set("synthesis")
  Human.notify({
    message = "Synthesizing insights",
    level = "info"
  })

  repeat
    Synthesizer.turn()
  until Tool.called("done", "synthesizer") or Iterations.exceeded(10)

  local synthesis = State.get("synthesis")

  Stage.set("complete")

  return {
    analysis = {
      plan = plan,
      technical = technical,
      business = business,
      synthesis = synthesis
    }
  }</div>

                <div class="info-box">
                    <strong>Key concepts:</strong>
                    <ul>
                        <li>Multiple specialized agents</li>
                        <li>Sequential agent execution</li>
                        <li>Shared state between agents</li>
                        <li>Agent-specific tool calls checking</li>
                        <li>Synthesis of multiple perspectives</li>
                    </ul>
                </div>
            </div>

            <div class="tip-box">
                <strong>Next Steps:</strong>
                <ul>
                    <li>Try modifying these examples for your use case</li>
                    <li>Combine patterns from multiple examples</li>
                    <li>Refer to the <a href="api-reference.html">API Reference</a> for all available primitives</li>
                    <li>Check the <a href="../AGENTS.md">AGENTS.md</a> for complete specification</li>
                </ul>
            </div>

            <div class="nav-links">
                <a href="hitl-guide.html">← Human-in-the-Loop Guide</a>
                <a href="api-reference.html">API Reference →</a>
            </div>
        </div>
    </div>
</body>
</html>
